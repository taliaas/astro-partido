---
import { getSession } from "auth-astro/server";
import CoreService from "../../services/CoreService";
import RootLayout from "../../layouts/RootLayout.astro";
import Busqueda from "../../components/filters/Busqueda.vue";
import SolrService from "../../services/SolrService";
import { API_URL } from "astro:env/client";

const session = (await getSession(Astro.request)) as any;

const ADMIN_ROLE_ID = 1; 
const COMITE_MEMBER_ROLE_ID = 4; 

// Interfaz para el usuario actual
interface CurrentUser {
  userId: number;
  roleId: number;
  coreId?: string;  
  name: string;
}

let currentUser: CurrentUser | null = null;
if (session?.user) {
  const userId = session.user.id;
  
  const possibleRoleId = 
    session.user.role?.id || 
    session.user.roleId;
  
  const possibleCoreId = 
    session.user.core?.id || 
    session.user.coreId || 
    session.user.militant?.core?.id ||
    session.user.militant?.coreId;
  
  currentUser = {
    userId: userId,
    roleId: possibleRoleId,
    coreId: possibleCoreId,
    name: session.user.name,
  };
}

// Función para determinar si el usuario tiene acceso total
function hasFullAccess(user: CurrentUser | null): boolean {
  if (!user) return false;
  return user.roleId === ADMIN_ROLE_ID || user.roleId === COMITE_MEMBER_ROLE_ID;
}

// Función para obtener el coreId del usuario mediante su militant
async function getUserCoreIdFromMilitant(userId: number): Promise<string | null> {
  if (!userId) {
    return null;
  }

  try {
    const apiUrl = API_URL || 'http://localhost:3000';
    const response = await fetch(`${apiUrl}/militant/user/${userId}`, {
      headers: {
        'Authorization': `Bearer ${session.jwt}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      return null;
    }

    const militant = await response.json();

    if (militant?.core?.id) {
      return militant.core.id;
    }

    return null;
  } catch (error) {
    return null;
  }
}

// Función para obtener el core del usuario
async function getUserCoreName(): Promise<string | null> {
  if (!currentUser) {
    return null;
  }

  // Si ya tenemos el coreId, usarlo
  if (currentUser.coreId) {
    const coreService = new CoreService();
    try {
      const allCores = await coreService.getAllCore(session.jwt);
      const userCore = allCores.find((c: any) => c.id === currentUser!.coreId);
      return userCore?.name || null;
    } catch (e) {
      return null;
    }
  }

  // Si no tenemos coreId pero tenemos userId, obtenerlo del militant
  if (currentUser.userId) {
    const coreId = await getUserCoreIdFromMilitant(currentUser.userId);
    
    if (coreId) {
      // Actualizar el coreId en currentUser
      currentUser.coreId = coreId;
      
      // Ahora obtener el nombre del core
      const coreService = new CoreService();
      try {
        const allCores = await coreService.getAllCore(session.jwt);
        const userCore = allCores.find((c: any) => c.id === coreId);
        return userCore?.name || null;
      } catch (e) {
        return null;
      }
    }
  }
  
  // intentar desde la sesión directamente
  if (session?.user?.militant?.core?.name) {
    return session.user.militant.core.name;
  }
  
  if (session?.user?.core?.name) {
    return session.user.core.name;
  }
  
  return null;
}

// --- Obtener parámetros de búsqueda ---
let query: any = {};
let searchParams = Astro.url.searchParams;

// Obtener el nombre del núcleo del usuario UNA VEZ
const userCoreName = await getUserCoreName();
const userHasFullAccess = hasFullAccess(currentUser);

if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  query = Object.fromEntries(
    Array.from(formData.entries()).filter((entry) => entry[1]),
  );

  //Aplicar restricción de núcleo si el usuaario NO tiene acceso total
  if (!userHasFullAccess && userCoreName) {
    query.core = userCoreName; // Forzar el filtro de núcleo
  }

  const params = new URLSearchParams(query);
  return Astro.redirect(`/busqueda?${params.toString()}&page=1&limit=10`);
} else {
  query = Object.fromEntries(searchParams.entries());

  // También aplicar restricción en GET 
  if (!userHasFullAccess && userCoreName) {
    // SIEMPRE forzar el core, incluso si viene en la URL
    query.core = userCoreName;
  }
}

const limit = Number(searchParams.get("limit")) || 10;
const page = Math.max(Number(searchParams.get("page")) || 1, 1);

// Verificar si hay filtros aplicados por el usuario (excluyendo page, limit, y core forzado)
function hasUserAppliedFilters(query: any): boolean {
  // Para usuarios con acceso restringido, el core se aplica automáticamente
  // así que lo excluimos de la verificación de filtros del usuario
  const isRestrictedUser = !userHasFullAccess;

  const keysToCheck = Object.keys(query).filter((key) => {
    // Excluir siempre page y limit
    if (key === "page" || key === "limit") return false;

    // Si es usuario restringido y el key es 'core', también excluir
    // porque se aplicó automáticamente
    if (isRestrictedUser && key === "core") return false;

    return true;
  });

  // Verificar si alguno de estos keys tiene valor
  return keysToCheck.some((key) => query[key]?.trim());
}

const hasActiveFilters = hasUserAppliedFilters(query);

// --- Función para obtener el término de búsqueda ---
function getSearchTerm(query: any): string {
  const terms: string[] = [];

  if (query.text?.trim()) terms.push(query.text.trim());
  if (query.name?.trim()) terms.push(query.name.trim());

  // Solo mostrar el núcleo en el término de búsqueda si el usuario tiene acceso total
  if (userHasFullAccess) {
    if (query.core?.trim()) terms.push(query.core.trim());
  }

  if (query.doc_type?.trim()) terms.push(query.doc_type.trim());

  if (query.dateFrom?.trim() || query.dateTo?.trim()) {
    const from = query.dateFrom?.trim() || "...";
    const to = query.dateTo?.trim() || "...";
    terms.push(`Fecha: ${from} - ${to}`);
  }

  return terms.join(", ");
}

// --- Servicios auxiliares ---
async function getActas() {
  // NO hacer búsqueda si no hay filtros aplicados
  return {
    docs: [],
    numFound: 0,
    total: 0,
    totalPages: 0,
    currentPage: page,
    searchTerm: "",
  };
}

async function getActasByQuery() {
  const service = new SolrService();
  const actasData = await service.queryMinutes(query, page, limit, "AND");
  
  // FILTRADO POST-QUERY: Si el usuario NO tiene acceso total, filtrar por núcleo
  let filteredDocs = actasData.docs || [];
  
  if (!userHasFullAccess && userCoreName) {
    // Filtrar solo las actas que pertenecen al núcleo del usuario
    filteredDocs = filteredDocs.filter((acta: any) => {
      const actaCore = acta.core?.trim();
      return actaCore === userCoreName;
    });
  }
  
  return {
    docs: filteredDocs,
    numFound: filteredDocs.length,
    total: filteredDocs.length,
    totalPages: Math.ceil(filteredDocs.length / limit),
    currentPage: page,
    searchTerm: getSearchTerm(query),
  };
}

async function getCore() {
  const service = new CoreService();
  try {
    const allCores = await service.getAllCore(session.jwt);
    return allCores;
  } catch (e) {
    if (session?.user?.core) {
      return [session.user.core];
    }
    return [];
  }
}

// --- Decidir si es búsqueda vacía o con filtros ---
// Solo hacer búsqueda si el usuario aplicó filtros
const actasResult = hasActiveFilters
  ? await getActasByQuery()
  : await getActas();

const actas = {
  docs: actasResult.docs || [],
  numFound: actasResult.numFound || 0,
  total: actasResult.total || 0,
  totalPages: actasResult.totalPages || Math.ceil((actasResult.numFound || 0) / limit),
  currentPage: actasResult.currentPage || page,
};

const searchTerm = actasResult.searchTerm || "";
let cores = await getCore();

// Asegurar que cores sea un array serializable
if (!cores || !Array.isArray(cores)) {
  cores = [];
}

// Si no hay cores, usar el del usuario desde la sesión
if (cores.length === 0 && session?.user?.core) {
  cores = [session.user.core];
}

// Serializar cores para pasarlo a Vue
const serializedCores = JSON.parse(JSON.stringify(cores));

// Calcular si debe mostrar el filtro de núcleo
// Solo Admin (roleId=1) y Comité CUJAE (roleId=6) pueden ver y usar el filtro
const showCoreFilter = Boolean(userHasFullAccess);
---

<RootLayout>
  <Busqueda
    actas={actas}
    limit={limit}
    page={page}
    cores={serializedCores}
    searchTerm={searchTerm}
    currentUser={currentUser}
    hasActiveFilters={hasActiveFilters}
    showCoreFilter={showCoreFilter}
    client:load
  />
</RootLayout>